/*
 * This source file was generated by the Gradle 'init' task
 */
package shootertargeting;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.math3.fitting.PolynomialCurveFitter;
import org.apache.commons.math3.fitting.WeightedObservedPoints;

public class ShooterTargetingWithDrag {
    private final double PI = 3.14159;
    private final double g = 9.8; // meters/second/second
    private final double thetaDegrees = 60.0;
    private final double theta = thetaDegrees/360.0*2.0*PI;
    private final double targetHeightInches = 72.0;
    private final double inchesToMeters = 2.54/100.0;
    private final double targetHeightMeters = targetHeightInches * inchesToMeters;
    private final double shooterHeightInches = 15.0;
    private final double shooterHeightMeters = shooterHeightInches* inchesToMeters;
    private final double rimRadius = 47.0/2.0 * inchesToMeters;
    private final double flywheelCircumference = 4.0 * PI * inchesToMeters;
    private final double rpmPerVolt = 473.0; // If we were operating in voltage control mode instead of velocity control.
    double shooterToTargetY = targetHeightMeters - shooterHeightMeters;
    //double offsetToRim = 24 * inchesToMeters; // Unused. intended to check height of the projectile at the rim.
    double fudge = 4.0; // extra (inches) radius to account for imperfections
    double ballRadius = (3 + fudge) * inchesToMeters;
    String[] contours = new String[81];

        public class Point {
        public double x;
        public double y;
        public Point(double x, double y) {
            this.x = x;
            this.y = y;
        }   
    }

    public class SimulationResult {
        public double distance;
        public double time;
        public double maxHeight;
        public double finalY;
        public List<Point> trajectory = new ArrayList<>();
        public SimulationResult() {
            this.distance = 0;
            this.time = 0;
            this.maxHeight = 0;
            this.trajectory = new ArrayList<>();
        }
        public void addPoint(double x, double y) {
            trajectory.add(new Point(x,y));
        }
        public double getDistance() {
            return distance;
        }
    }
    public void runSimulations() {
        WeightedObservedPoints distanceToRpm = new WeightedObservedPoints();
        for (int i = 0; i < 81; i++) {
            contours[i] = String.format("%3.1f",-8.0 + i * 0.1);
        }
        for (double rpm = 1000; rpm <= 5000; rpm += 500) {
            
            double initialVelocity = (rpm / 60.0) * flywheelCircumference;

            SimulationResult result = simulateWithDrag(
                rpm,
                theta,
                initialVelocity,
                ballRadius,
                0.27, // mass in kg
                shooterToTargetY,
                0.001 // timestep
            );
            boolean okay = checkHeightAtTheRim(result);
            if (okay)
               distanceToRpm.add(result.getDistance(), rpm);

            System.out.printf("%d RPM: %5.0f  Distance: %5.2f meters MaxHeight=%5.2f Yf=%5.2f time=%5.4f\n", (okay ? 1 : 0), rpm, result.getDistance(),
                result.maxHeight, result.finalY, result.time);
                plotResults(rpm, result);
        }
        // find a polynomial function that fits the data
        PolynomialCurveFitter fitter = PolynomialCurveFitter.create(3);
        double[] coeff = fitter.fit(distanceToRpm.toList());
        System.out.println("Fitted polynomial coefficients: ax^3 + bx^2 + cx + d where x = distance from shooter to target in meters");
        System.out.printf("a =%10.5f\n", coeff[3]);
        System.out.printf("b =%10.5f\n", coeff[2]);
        System.out.printf("c =%10.5f\n", coeff[1]);
        System.out.printf("d =%10.5f\n", coeff[0]);
        
        /*for (double d = 0; d < maxRange; d+= 0.5) {
            double rpm = coeff[0] + coeff[1]*d + coeff[2]*d*d + coeff[3]*d*d*d;
            System.out.printf("Distance: %5.2f  RPM: %5.0f\n", d, rpm);
        }*/
        for (int i = 0; i < 81; i++) {
            System.out.println(contours[i]);
        }

    }

    public static void main(String... args) {
        ShooterTargetingWithDrag simulation = new ShooterTargetingWithDrag();
        simulation.runSimulations();
        
       
        
    }
    public SimulationResult simulateWithDrag(
        double rpm,
        double theta,
        double v0,
        double radius,
        double mass,
        double height,
        double timestep
    )
    {
        SimulationResult result = new SimulationResult();
        double x = 0.0;
        double y = 0.0;
        double time = 0.0;
        double cosTheta = Math.cos(theta);
        double sinTheta = Math.sin(theta);
        double dx = v0 * cosTheta * timestep;
        double dy = v0 * sinTheta * timestep;
        double v = v0;
        double vx = v0 * cosTheta;
        double vy = v0 * sinTheta;
        double g = 9.8;
        double pi = 3.14159;
        double area = pi * radius * radius;
        double airDensity = 1.225; // kg/m^3
        double dragCoefficient = 0.47; // Sphere
        double dragConstant = 0.5 * airDensity * area * dragCoefficient;
        double simTheta;
        double yMax = 0;
        result.addPoint(0,0); // Always starting at 0.0;
        // Loop while we are going up or we are above the target height.
        while ((y >= 0.0) && (dy > 0.0 || y > height )) {
            // update position
            x += vx * timestep;
            dy = vy * timestep;
            y += vy * timestep;
            if (y > yMax) {
                yMax = y;
            }
            result.addPoint(x, y);
            simTheta = Math.atan2(vy, vx);
            // Compute forces
            double fdrag = v * v * dragConstant;
            double fdragX = fdrag * Math.cos(simTheta);
            double fdragY = fdrag * Math.sin(simTheta);
            double ax = -fdragX/mass;
            double ay = -9.8 - (fdragY/mass);
            // Update velocities
            vx += ax * timestep;
            vy += ay * timestep;
            v = Math.sqrt(vx * vx + vy * vy);
            time += timestep;
        }
        result.distance = x;
        result.time = time - timestep;
        result.maxHeight = yMax;
        result.finalY = y;
        return result;
    } 

    public boolean checkHeightAtTheRim(SimulationResult result) {
        if (result.maxHeight - ballRadius > targetHeightMeters) return true;
        for (Point p : result.trajectory) {
            if (p.x >= result.distance - rimRadius && p.x <= result.distance + rimRadius) {
                double heightAtRim = p.y;
                if (heightAtRim - ballRadius < targetHeightMeters) {
                    return false;
                }
            }
        }
        return true; // No problems found
    }

    public void plotResults(double rpm, SimulationResult result) {
        WeightedObservedPoints pts =  new WeightedObservedPoints();

        for (Point point : result.trajectory) {
            pts.add(point.x, point.y);
        }
        PolynomialCurveFitter fitter = PolynomialCurveFitter.create(3);
        double[] coeff = fitter.fit(pts.toList());
        for(int i = 0; i < 81; i++) {
            double x = -8.0 + i * 0.1;
            double xx = x + result.distance;
            double y;
            if (xx < 0) {
                y = 0.0;
            } else {
                y = coeff[0] + coeff[1]*xx + coeff[2]*xx*xx + coeff[3]*xx*xx*xx; // + coeff[4]*xx*xx*xx*xx;
            }
            contours[i] += "\t"+ String.format("%5.3f",y);
            //System.out.printf("%5.3f\n", y);
        }

    }   
}
